# Module Federation with React and TypeScript

This project demonstrates the implementation of **Webpack 5 Module Federation** in a React application with TypeScript. It showcases how to build a **micro frontend architecture** where independent applications can share components dynamically at runtime.

## 📋 Table of Contents

- [Overview](#overview)
- [What is Module Federation](#what-is-module-federation)
- [Project Architecture](#project-architecture)
- [Project Structure](#project-structure)
- [Applications Overview](#applications-overview)
- [Key Technologies](#key-technologies)
- [Setup and Installation](#setup-and-installation)
- [Running the Applications](#running-the-applications)
- [How Module Federation Works Here](#how-module-federation-works-here)
- [Webpack Configuration Explained](#webpack-configuration-explained)
- [Shared Dependencies](#shared-dependencies)
- [Development Workflow](#development-workflow)
- [Troubleshooting](#troubleshooting)
- [Benefits of This Architecture](#benefits-of-this-architecture)
- [License](#license)

## 🎯 Overview

This project consists of **three independent React applications** that work together using Webpack 5's Module Federation:

1. **Header Application** (`header-app`) - Provides a navigation header component
2. **Footer Application** (`footer-app`) - Provides a footer component  
3. **Host Application** (`host`) - Consumes and orchestrates the header and footer components

Each application can run independently or be consumed by other applications, demonstrating the power of micro frontend architecture.

## 🔍 What is Module Federation

**Module Federation** is a feature introduced in Webpack 5 that allows multiple separate applications to share modules at runtime. It enables:

- **Runtime composition** of applications
- **Independent deployments** of micro frontends
- **Shared dependencies** to avoid code duplication
- **Dynamic imports** of remote modules
- **Version compatibility** management between applications

## 🏗️ Project Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Header App    │    │   Footer App    │    │    Host App     │
│   Port: 3001    │    │   Port: 3002    │    │   Port: 3000    │
│                 │    │                 │    │                 │
│ Exposes:        │    │ Exposes:        │    │ Consumes:       │
│ ./Header        │    │ ./Footer        │    │ headerApp/Header│
│                 │    │                 │    │ footerApp/Footer│
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │  remoteEntry.js │
                    │  (Generated by  │
                    │   each remote)  │
                    └─────────────────┘
```

## 📁 Project Structure

```
module-federation-react-ts-1/
├── header-app/                    # Header micro frontend
│   ├── src/
│   │   ├── components/
│   │   │   ├── Header.tsx         # Main header component
│   │   │   └── Header.css         # Header styling
│   │   ├── App.tsx                # Header app main component
│   │   ├── index.tsx              # Entry point
│   │   └── bootstrap.tsx          # Async bootstrap for MF
│   ├── public/
│   │   └── index.html             # HTML template
│   ├── package.json               # Dependencies and scripts
│   ├── tsconfig.json              # TypeScript configuration
│   └── webpack.config.js          # Webpack + Module Federation config
├── footer-app/                    # Footer micro frontend
│   ├── src/
│   │   ├── components/
│   │   │   ├── Footer.tsx         # Main footer component
│   │   │   └── Footer.css         # Footer styling
│   │   ├── App.tsx                # Footer app main component
│   │   ├── index.tsx              # Entry point
│   │   └── bootstrap.tsx          # Async bootstrap for MF
│   ├── public/
│   │   └── index.html             # HTML template
│   ├── package.json               # Dependencies and scripts
│   ├── tsconfig.json              # TypeScript configuration
│   └── webpack.config.js          # Webpack + Module Federation config
├── host/                          # Host application (shell)
│   ├── src/
│   │   ├── components/
│   │   │   └── Main.tsx           # Main content component
│   │   ├── App.tsx                # Host app orchestrator
│   │   ├── index.tsx              # Entry point
│   │   └── remoteTypes.d.ts       # TypeScript declarations for remotes
│   ├── public/
│   │   └── index.html             # HTML template
│   ├── package.json               # Dependencies and scripts
│   ├── tsconfig.json              # TypeScript configuration
│   └── webpack.config.js          # Webpack + Module Federation config
└── README.md                      # This documentation
```

## 🏢 Applications Overview

### Header Application (Port 3001)
- **Purpose**: Provides a reusable navigation header component
- **Exposes**: `./Header` component via Module Federation
- **Independent**: Can run standalone for development/testing
- **Features**: Navigation links, responsive design, modern styling

### Footer Application (Port 3002)  
- **Purpose**: Provides a reusable footer component
- **Exposes**: `./Footer` component via Module Federation
- **Independent**: Can run standalone for development/testing
- **Features**: Copyright info, footer links, responsive design

### Host Application (Port 3000)
- **Purpose**: Main application shell that orchestrates other micro frontends
- **Consumes**: Header from `headerApp` and Footer from `footerApp`
- **Features**: Main content area, lazy loading of remote components, error boundaries

## 🛠️ Key Technologies

- **React 17** - Frontend library for building user interfaces
- **TypeScript 4.4** - Type-safe JavaScript superset
- **Webpack 5** - Module bundler with Module Federation support
- **Module Federation** - Webpack 5 feature for micro frontend architecture
- **pnpm** - Fast, disk space efficient package manager
- **CSS Modules** - Scoped CSS styling
- **Hot Module Replacement (HMR)** - Live reloading during development

## ⚙️ Setup and Installation

### Prerequisites
- Node.js (v14 or higher)
- pnpm package manager

### Installation Steps

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd module-federation-react-ts-1
   ```

2. **Install dependencies for each application**
   ```bash
   # Install header-app dependencies
   cd header-app
   pnpm install
   
   # Install footer-app dependencies
   cd ../footer-app
   pnpm install
   
   # Install host dependencies
   cd ../host
   pnpm install
   ```

## 🚀 Running the Applications

**Important**: All three applications must be running simultaneously for the Module Federation to work properly.

### Start Each Application (in separate terminals)

1. **Start Header Application**
   ```bash
   cd header-app
   pnpm start
   # Runs on http://localhost:3001
   ```

2. **Start Footer Application**
   ```bash
   cd footer-app
   pnpm start
   # Runs on http://localhost:3002
   ```

3. **Start Host Application**
   ```bash
   cd host
   pnpm start
   # Runs on http://localhost:3000
   ```

### Access the Applications

- **Host Application**: http://localhost:3000 (Complete application with header + footer)
- **Header Application**: http://localhost:3001 (Standalone header)
- **Footer Application**: http://localhost:3002 (Standalone footer)

## 🔧 How Module Federation Works Here

### 1. Remote Entry Points
Each remote application (header-app, footer-app) generates a `remoteEntry.js` file that contains:
- Metadata about exposed modules
- Runtime loading mechanisms
- Dependency information

### 2. Exposing Components (Remote Applications)
```javascript
// In header-app/webpack.config.js
new ModuleFederationPlugin({
  name: "headerApp",
  filename: "remoteEntry.js",
  exposes: {
    "./Header": "./src/components/Header", // Expose Header component
  },
  // ...
})
```

### 3. Consuming Components (Host Application)
```javascript
// In host/webpack.config.js
new ModuleFederationPlugin({
  name: "hostApp",
  remotes: {
    headerApp: "headerApp@http://localhost:3001/remoteEntry.js",
    footerApp: "footerApp@http://localhost:3002/remoteEntry.js",
  },
  // ...
})
```

### 4. Dynamic Imports in Host
```typescript
// In host/src/App.tsx
const Header = lazy(() => import('headerApp/Header'));
const Footer = lazy(() => import('footerApp/Footer'));
```

## 📋 Webpack Configuration Explained

### Remote Applications Configuration (header-app, footer-app)

```javascript
new ModuleFederationPlugin({
  name: "headerApp",                    // Unique name for this remote
  filename: "remoteEntry.js",           // Entry file for remote consumption
  exposes: {
    "./Header": "./src/components/Header" // Export Header component
  },
  shared: {
    react: { 
      singleton: true,                  // Only one instance of React
      requiredVersion: "^17.0.2"       // Version requirement
    },
    "react-dom": { 
      singleton: true, 
      requiredVersion: "^17.0.2" 
    }
  }
})
```

### Host Application Configuration

```javascript
new ModuleFederationPlugin({
  name: "hostApp",                      // Name of the host application
  remotes: {
    headerApp: "headerApp@http://localhost:3001/remoteEntry.js",
    footerApp: "footerApp@http://localhost:3002/remoteEntry.js"
  },
  shared: {
    react: { 
      singleton: true, 
      eager: true,                      // Load immediately in host
      requiredVersion: "^17.0.2" 
    },
    "react-dom": { 
      singleton: true, 
      eager: true, 
      requiredVersion: "^17.0.2" 
    }
  }
})
```

## 📦 Shared Dependencies

### Why Share Dependencies?
- **Avoid duplication**: Prevent multiple copies of React/ReactDOM
- **Consistency**: Ensure all apps use the same version
- **Performance**: Reduce bundle size and memory usage

### Configuration Options
- **`singleton: true`**: Only one instance across all apps
- **`eager: true`**: Load immediately (only for host)
- **`requiredVersion`**: Specify compatible versions
- **`shareScope`**: Namespace for shared modules

## 🔄 Development Workflow

### Making Changes
1. Edit any component in header-app, footer-app, or host
2. Changes will be reflected via Hot Module Replacement (HMR)
3. Host application automatically receives updates from remote applications

### Adding New Components
1. Create component in appropriate remote application
2. Export it in webpack.config.js `exposes` section
3. Import and use in host application

### Independent Development
Each application can be developed and tested independently:
```bash
# Test header component in isolation
cd header-app && pnpm start

# Test footer component in isolation  
cd footer-app && pnpm start
```

## 🐛 Troubleshooting

### Common Issues and Solutions

#### 1. "Shared module is not available for eager consumption"
- **Cause**: Incorrect eager loading configuration
- **Solution**: Remove `eager: true` from remote applications, keep only in host

#### 2. "Loading chunk failed"
- **Cause**: Remote application not running
- **Solution**: Ensure all applications (header, footer, host) are running

#### 3. Hot reload not working
- **Solution**: Check webpack devServer configuration and ensure HMR is enabled

#### 4. TypeScript errors for remote modules
- **Solution**: Update `remoteTypes.d.ts` with correct module declarations

#### 5. CORS issues
- **Solution**: Add CORS headers in webpack devServer configuration

## ✅ Benefits of This Architecture

### For Development Teams
- **Independent deployments** of each micro frontend
- **Technology diversity** - different teams can use different versions/libraries
- **Parallel development** - teams can work independently
- **Code isolation** - changes in one app don't affect others

### For Applications
- **Runtime composition** - no build-time coupling
- **Shared dependencies** - reduced bundle sizes
- **Lazy loading** - load components only when needed
- **Fallback handling** - graceful degradation if remote fails

### For Users
- **Better performance** - smaller initial bundles
- **Progressive loading** - components load as needed
- **Consistent experience** - shared design system across apps

## 🏆 Production Considerations

When deploying to production:
1. **Configure proper URLs** for remote entries (not localhost)
2. **Set up proper CORS** headers on hosting servers
3. **Implement error boundaries** for remote component failures
4. **Add loading states** and fallbacks
5. **Monitor performance** of remote loading
6. **Version management** strategy for shared dependencies

## 🚀 Image

![Captura de tela 2025-05-28 154311](https://github.com/user-attachments/assets/fc20f919-e593-46c4-b567-a6a9c63e52de)



## 📝 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

**Note**: This is a demonstration project showcasing Module Federation concepts. For production use, additional considerations around error handling, performance optimization, and deployment strategies should be implemented.
